import * as T from "./types";

export type ID = string;
export type ErrorResponse = { ok: false; error: string };
export type DeleteResponse = ErrorResponse | { ok: true };
export type MutationResponse<T> = ErrorResponse | { ok: true; data: T };
export type QueryResponse<T> = ErrorResponse | { ok: true; total: number; data: T };

export async function request<T>(url: string, init?: RequestInit) {
    const headers = {
        "content-type": "application/json",
        ...init?.headers,
    };

    const response = await fetch(url, {
        ...init,
        credentials: "include",
        headers,
    });

    if (response.headers.get("content-type") == "application/json") {
        {{ if .Config.Debug }}
        const json = (await response.json()) as T;
        console.log({
            url,
            body:
                init && init.body
                    ? JSON.parse(init?.body?.toString())
                    : undefined,
            response: json,
        });
        return json;
        {{else}} 
        return response.json() as T;
        {{ end }}
    } else {
     {{ if .Config.Debug }}
        console.log({
            url,
            body:
                init && init.body
                    ? JSON.parse(init?.body?.toString())
                    : undefined,
            response: { ok: false, error: "unknown error on request" },
        });
     {{ end }}
        return { ok: false, error: "unknown error on request" } as T;
    }
}

export function Api(url: string) {
    url = url.replace(/\/+$/, "");
    return {
        {{ range .Schemas }}
        {{ snake .Name }}: {
            {{ if ignore_query . | not }}  
            query: async (query?: T.{{ pascal .Name }}QueryInput) =>
                request<Promise<QueryResponse<Array<T.{{ pascal .Name }}>>>>(
                    `${url}/{{ plural .Name | kebab }}${
                        query ? `?query=${JSON.stringify(query)}` : ""
                    }`,
                    {}
                ),
            {{ end }}
            {{ if ignore_create . | not }} 
            create: async (input: T.{{ pascal .Name }}CreateInput) =>
                request<Promise<MutationResponse<T.{{ pascal .Name }}>>>(`${url}/{{ plural .Name | kebab }}`, {
                    method: "POST",
                    body: JSON.stringify(input),
                }),
            {{ end -}}
            {{ if ignore_update . | not }} 
            update: async (input: T.{{ pascal .Name }}UpdateInput) =>
                request<Promise<MutationResponse<T.{{ pascal .Name }}>>>(`${url}/{{ plural .Name | kebab }}`, {
                    method: "PATCH",
                    body: JSON.stringify(input),
                }),
            {{ end -}}
            {{ if ignore_delete . | not }} 
            delete: async (id: ID) =>
                request<Promise<DeleteResponse>>(`${url}/{{ plural .Name | kebab }}/${id}`, {
                    method: "DELETE",
                }),
            {{ end }}
        },
        {{ end }}
    };
}
